---
title: "[Day17] 순열/조합/부분집합"
categories: [Ureca, Algorithm]
tags: [Queue, Counting Sort, Quick Sort, Merge Sort]
image:
  path: /assets/post/2025/ureca/algorithm6.webp
  alt: java
published: true
---


# 순열, 조합, 부분집합 정리  

## 순열 (Permutation)  
- **순서가 중요**하며 **중복을 허용하지 않음**  
- 가능한 모든 경우를 고려해야 하므로 시간복잡도는 **O(n!)**  

### 예제: 주사위 던지기 (순열)  
```java
import java.util.Arrays;

public class A01_주사위_일반순열 {
    static int totalCnt; // 완성된 순열의 수
    static int n; // 주사위 던지는 횟수
    static int[] results; // 순열 결과를 저장할 배열
    static boolean[] isSelected; // 중복 체크를 위한 배열

    public static void main(String[] args) {
        n = 2; // 주사위를 2번 던짐
        results = new int[n];
        isSelected = new boolean[7]; // 1~6번 index만 사용
        주사위던지기(0);
        System.out.println(totalCnt);
    }

    public static void 주사위던지기(int cnt) {
        if (cnt == n) {
            totalCnt++;
            System.out.println(Arrays.toString(results));
            return;
        }

        for (int i = 1; i <= 6; i++) {
            if (isSelected[i]) continue;
            results[cnt] = i;
            isSelected[i] = true;
            주사위던지기(cnt + 1);
            isSelected[i] = false;
        }
    }
}
```

### 📌 설명:

- isSelected 배열을 사용하여 중복을 방지
- cnt == n일 때 결과 출력
- for문에서 사용한 숫자는 다시 사용하지 않도록 isSelected[i] = true

---

## 조합 (Combination)
- 순서는 중요하지 않으며, 중복을 허용하지 않음
- 일반적으로 재귀를 이용하여 해결
- 시간복잡도: O(2^n) ~ O(nCr)

### 예제: 주사위 던지기 (조합)
```java
import java.util.Arrays;

public class A02_주사위_일반조합 {
    static int totalCnt; // 완성된 조합의 수
    static int n; // 주사위 던지는 횟수
    static int[] results; // 조합 결과 저장

    public static void main(String[] args) {
        n = 2; 
        results = new int[n];

        주사위던지기(0, 1);
        System.out.println(totalCnt);
    }

    public static void 주사위던지기(int cnt, int start) {
        if (cnt == n) {
            totalCnt++;
            System.out.println(Arrays.toString(results));
            return;
        }

        for (int i = start; i <= 6; i++) {
            results[cnt] = i;
            주사위던지기(cnt + 1, i + 1);
        }
    }
}
```

### 📌 설명:
- start 값을 사용하여 중복을 방지
- 주사위던지기(cnt + 1, i + 1); → 이전 값보다 큰 숫자만 선택

## 부분집합 (Subset)
- 모든 경우의 조합을 고려해야 하며, 선택하거나 선택하지 않는 2가지 경우로 진행
- 시간복잡도: O(2^n)

### 예제: 주사위 숫자의 부분집합
```java
public class A03_주사위_부분집합 {	
    static int totalCnt; // 부분집합의 총 개수	
    static int[] input = {1, 2, 3, 4, 5, 6}; // 주사위 숫자	
    static boolean[] isSelected; // 선택 여부를 저장하는 배열

    public static void main(String[] args) {		
        isSelected = new boolean[6];	
        subset(0); // 부분집합 생성	
        System.out.println(totalCnt);
    }
    
    public static void subset(int cnt) {
        if (cnt == 6) {
            ++totalCnt;
            for (int i = 0; i < 6; i++) {
                System.out.print((isSelected[i] ? input[i] : "X") + " ");
            }
            System.out.println(); 
            return; 
        }
        
        isSelected[cnt] = true; // 선택
        subset(cnt + 1);
        
        isSelected[cnt] = false; // 선택 안 함
        subset(cnt + 1);
    }
}
```

### 📌 설명:

- isSelected[cnt] = true → 현재 원소 포함
- isSelected[cnt] = false → 현재 원소 미포함
- 모든 경우를 탐색

### ✅ 정리
| 구분     | 중복 | 순서 | 시간복잡도 |
|----------|------|------|------------|
| 순열 | X    | O    | O(n!)      |
| 조합 | X    | X    | O(nCr)     |
| 부분집합 | -  | X    | O(2^n)     |


### 🔹 언제 사용할까?
- 순열: 모든 경우의 수를 고려할 때 (ex. 암호 생성, 경로 탐색)
- 조합: 선택된 원소들만 고려할 때 (ex. 팀 구성, 메뉴 조합)
- 부분집합: 특정 조건을 만족하는 부분 집합을 찾을 때 (ex. 특정 합을 만드는 집합)


---

